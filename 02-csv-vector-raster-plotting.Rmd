---
layout: post
title: "Lesson 02: Converting from .csv to Shapefile in R"
date:   2015-10-24
authors: [Joseph Stachelek, Leah Wasser, Megan A. Jones]
contributors: [Sarah Newman]
dateCreated:  2015-10-23
lastModified: `r format(Sys.time(), "%Y-%m-%d")`
packagesLibraries: [rgdal, raster]
category: 
mainTag: spatial-vector-series
tags: [vector-data]
description: "This lesson walks through how to convert a .csv file that contains
coordinate information into a spatial object in R."
code1: 02-csv-vector-raster-plotting.R
image:
  feature: NEONCarpentryHeader_2.png
  credit: A collaboration between the National Ecological Observatory Network (NEON) and Data Carpentry
  creditlink: http://www.neoninc.org
permalink: /R/csv-to-shapefile-R/
comments: false
---

{% include _toc.html %}

#About

This lesson will review how to import spatial points stored in a .csv file into
`R` as a spatial object - a `SpatialPointsDataFrame`. We will also learn how to
reproject data imported in a shapefile format into another projection, create a 
shapefile from a spatial object in `R`, and plot raster and vector data as
layers in the same plot. 

**R Skill Level:** Intermediate - you've got the basics of `R` down.

<div id="objectives" markdown="1">

##Goals / Objectives
After completing this activity, you will:

* Be able to import .csv files containing x,y coordinate locations into `R`.
* Know how to convert a .csv to a spatial object.
* Understand how to project coordinate locations provided in a Geographic
Coordinate System (Latitude, Longitude) to a projected coordinate system (UTM).
* Be able to plot raster and vector data in the same plot to create a map.

##Things You'll Need To Complete This Lesson
You will need the most current version of `R` and, preferably, RStudio loaded on
your computer to complete this lesson.

##R Libraries to Install:

* **raster:** `install.packages("raster")`
* **rgdal:** `install.packages("rgdal")`

<a href="{{ site.baseurl }}/R/Packages-In-R/" target="_blank"> 
More on Packages in R - Adapted from Software Carpentry.</a>

##Data to Download
{% include/dataSubsets/_data_Site-Layout-Files-HARV.html %}

{% include/dataSubsets/_data_Airborne-RemoteSensing-HARV-SJER.html %}

**Set Working Directory:** This lessons assumes that you have set your working 
directory to the location of the downloaded and unzipped data subset. 
[An overview of setting the working directory in `R` can be found here.]({{site.baseurl}}/R/Set-Working-Directory "R Working Directory Lesson") 

**Challenge Code:** NEON Data Skills tutorials often contain challenges that
reinforce learned skills. If available, the code for challenge solutions is
found in a downloadable `R` script available on the footer of each lesson page.

**Vector Lesson Series:** This lesson is a part of a lesson series on 
[spatial vector data in `R`]({{site.baseurl}}/R/spatial-vector-lessons).
</div>

#Create a Map
The `HARV_PlotLocations.csv` file contains x,y locations for some 
<a href="http://www.neoninc.org/science-design/collection-methods/terrestrial-organismal-sampling" target="_blank">  
plots that NEON field crews </a>
are sampling vegetation and other ecological metrics. We would like to

* create a map of the locations of these plot locations. 
* export the data in a `shapefile` format to share with our colleagues. This
shapefile could then be imported into any GIS software.
* create a map combining a raster Canopy Height Model with the vector
shapefiles.

Spatial data are downloaded from a website, off a GPS, or transcribed from old 
field notes are stored in a text file format (`.txt` or `.csv`). We can convert
these text format data into a spatial object as an `R` 
`SpatialPointsDataFrame`. The `SpatialPointsDataFrame` format allows us to store
both the x,y values that are the coordinates but also the columns describing
associated metadata or associated attributes.  

<i class="fa fa-star"></i> **Data Tip:** There is a `SpatialPoints` object (not
`SpatialPointsDataFrame`) in `R` that does not allow you to store associated
attributes. 
{: .notice}

##Reading in a .csv
To begin we need to read in the .csv file that contains the x,y coordinate
locations of the plots (`HARV_PlotLocations.csv`).

```{r read-csv }
#load packages
library(rgdal)  #for vector work; sp package should always load with rgdal. 
library (raster)   #for metadata/attributes- vectors or rasters

#set working directory to data folder
#setwd("pathToDirHere")

#Read the .csv file
plot.locations_HARV <- 
  read.csv("NEON-DS-Site-Layout-Files-HARV/HARV/HARV_PlotLocations.csv")

#look at the data structure
str(plot.locations_HARV)

```

`plot.locations_HARV` is a `data.frame` of 21 locations (rows) with 43 variables
(attributes) each.  

<div id="challenge" markdown="1">
##Challenge:  Data Structure & CRS
What is the coordinate reference system (`CRS`) for this data? (Hint: Try what
you may know about finding the `CRS` in spatial data, but don't struggle too
long before reading the next bit.)
</div>
```{r challenge-code-crs, include=TRUE, results="hide", echo=FALSE}
crs(plot.locations_HARV)

attributes(plot.locations_HARV)

```

#Determine a Coordinate Reference System
When we create a spatial points `data.frame` from a .csv, there is no inherent
CRS associated with it. We must assign a CRS based knowledge of the coordinate
system the x,y values are in.

How do we know what the correct CRS for the data is? There are several ways we 
know this.  

1.  We collected the data ourselves and know from the GPS what the CRS, x,y
values, and units are. 
2. The source of our .csv file for the data points also has a .txt (or similar)
file with metadata about the data.  For more information on metadata in
associated files check out the
[Understanding Time Series Metadata]({{site.baseurl}}/R/Time-Series-Metadata) 
lesson. 
3. We look at the data in our .csv (now `R` object) to see if it gives any
hints.

First, we'll look at the file names. 
```{r crs-sleuthing} 
#view the column names
names(plot.locations_HARV)

```

Okay, there are several columns related to a CRS.  Let's check out the first to
rows of the `data.frame` to see what information is in these columns.

```{r crs-sleuthing2} 
#view the first 6 rows
head(plot.locations_HARV)
```

We have the following information that is relevant to a CRS: 

* X: 73xxxx.3 -- no other information but these match the eastings
* Y: 4713xxx -- no other information but these match the northings
* decimalLat: 42.5xxxx
* decimalLon: -72.1xxx
* geodeticDa: WGS84  -- this is geodetic datum WGS84
* utmZone: 18N
* easting: 73xxxx.3
* northing: 4713xxx

What can we make our of this?   We have a geographic coordinate system (Latitude
and Longitude, both in decimal degrees) and a projected coordinate system (UTM
in Zone18N with Eastings and Northings).  Importantly for the projection we know
that the datum is WGS84.  

#Convert .csv to Shapefile
Before we can combine our plot locations with the boundaries of our field site, 
or other spatial data we need to convert the locations from a .csv file to a
`SpatialPointsDataFrame`.  When we make the conversion, we also have to specify 
what the correct `crs`, datum, and other information.  We do this using a
`proj4string`.  As we are going to be projecting this data on a 2D surface to
make a map. We'll convert to a `SpatialPointsDataFrame` based on the UTM
coordinates. 

What is a `proj4string`? This is a string with specific information about the
`crs` and related information for the data in a spatial file.  The format
changes depending on the projection used.  This format is for UTMs. 
`+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0`

* +proj=utm     the projection -- we know our data is in UTM
* +zone=18      the UTM zone -- we know our data is in 18N but N isn't needed
* +datum=WGS84  the datum -- we know our data is in WGS84
* +units=m      the coordinate value units -- UTM is by default meters (m)
* +no_defs      with rare exceptions this default used 
* +ellps=WGS84  which mapping ellipse was used -- we'll match the datum 
* +towgs84=0,0,0  conversion from current datum/ellipse to WGS84 -- nothing,
we're already in WGS84 for both.  

* For more information on <a href="http://proj.maptools.org/faq.html" target="_blank"> proj4.</a>
* For information on datums in `R`: `projInfo(type = "datum")`

Now we can convert the .csv file. 
```{r convert-csv-shapefile}
#Which data.frame columns represent the UTMs?
names(plot.locations_HARV)
#X, Y are 1:2 or easting,northing are 23:24.  We can use either.

#create an object defining the CRS in proj4string format
#could be in the conversion code but this is cleaner coding.
CRS_plot_HARV<- CRS("+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs
                    +ellps=WGS84 +towgs84=0,0,0")

plot.locationsSp_HARV <- SpatialPointsDataFrame(plot.locations_HARV[,23:24],
                # [,23:24]the columns which represent UTM coordinate locations 
                    plot.locations_HARV,    #the R object to convert
                    proj4string = CRS_plot_HARV)   # assign a CRS 
                                          
#look at CRS
crs(plot.locationsSp_HARV)

```

#Load Shapefiles 
We now have a spatial `R` object. We can plot our data!

```{r plot-data-points }
plot(plot.locationsSp_HARV, main="Map of Plot Locations")

# Save plot 
Harv_plotLocMap<- recordPlot()
```

While our points do plot the map isn't very informative.  We can bring in other
spatial objects to create a better map. 

Let's bring in shapefiles for a field site boundary, roads & trails, and a tower
location in Harvard Forest. (If you completed
[Shapefile Metadata & Attributes in R]({{site.baseurl}}/R/shapefile-attributes-in-R/)
lesson you already have these `R` objects).

```{r read-shp }
#note: readOGR is preferred as it maintains the projection infomation
#Import Field site boundary
aoiBoundary_HARV <- readOGR("NEON-DS-Site-Layout-Files-HARV/HARV",
                            "HarClip_UTMZ18")

#Import a roads/trails
lines_HARV <- readOGR( "NEON-DS-Site-Layout-Files-HARV/HARV/", "HARV_roads")

#Import a tower point
point_HARV <- readOGR("NEON-DS-Site-Layout-Files-HARV/HARV/",
                      "HARVtower_UTM18N")

```

These are shapefiles that we want to match up with our, now converted, .csv
file.  It is important to first confirm that both spatial objects have the same 
CRS.

```{r check-crs-shapefile-csv}
#check the CRS in shapefile
crs(plot.locationsSp_HARV)
crs(aoiBoundary_HARV)
crs(lines_HARV)
crs(point_HARV)
```

Yep, they are all the same.  We can now plot the shapefiles together.  

``` {r plot-data-maps}
#recall the original plot location map; optional
Harv_plotLocMap

#Add Field Site Boundary polygon & tower point layer to our "Map of Study Area"
plot(aoiBoundary_HARV, add=TRUE)
plot (point_HARV, col="red", add=TRUE)
plot(lines_HARV, add=TRUE)

# save this newer map
Harv_plotLocMap2<- recordPlot()
```

What happened to the tower?

The extent of the study plot locations covers a larger area than the
`aoiBoundary_HARV` file that we originally originally projected.  

```{r extent-files}
extent(aoiBoundary_HARV)
extent (plot.locationsSp_HARV)
```

#Borrow a CRS When Converting to a Spatial.Data.Frame
When we just convert our imported `plot.location_HARV` object to a
`SpatialPointsDataFrame` we assign it a `CRS` using a written out `proj4string`.
However, if we'd already had a Spatial.Data.Frame object with the same `CRS`)
(such as `aoiBoundary_HARV`, `lines_HARV` or `point_HARV`) we could have simply
borrowed the `CRS` from that object to use in the conversion.  

We'd just identify the file from which we'd use the `CRS` when doing the
conversion.  

``` {r plot-csv-shapefile}

plot.locations_HARV_matchCRS <-
               SpatialPointsDataFrame(plot.locations_HARV[,23:24],
                                      plot.locations_HARV,    # object to convert
                                      proj4string = crs(aoiBoundary_HARV))
                                    #assign CRS to match `aoiBoundary_HARV CRS
#check to make sure it worked
crs(plot.locations_HARV_matchCRS)
```

WARNING: We still have to know the correct `CRS` for the data and 
use a file with a matching `CRS`.  This doesn't solve our problems if we DO NOT 
know our `CRS`. 

#Create a New Shapefile from A Spatial Object

We can write an `R` spatial object to a shapefile using the `writeOGR` function 
in `rgdal`. To do this we need the following arguments:

* the name of the spatial object (`plot.locationsSp_HARV`)
* the directory where we want to save our shapefile
           (to use current = getwd() or you can specify a different path)
* the name of the new shapefile  ("PlotLocations_HARV")
* the driver which specifies the file format (ESRI Shapefile)

We can now write the shapefile. 

``` {r write-shapefile}
#write a shapefile
writeOGR(plot.locationsSp_HARV, getwd(),
         "PlotLocations_HARV", driver="ESRI Shapefile")

```


#Spatial Objects in Different CRSs
Too often, we have data that are in different `CRS`s. In order to map these
objects in geographic space we need to reproject one or the other so that 
they will line up on a map.

Let's explore reprojecting a spatial data object using a new study plot 
location (shapefile: "newPlot_latLon").

```{r project-vectors }
#note: readOGR is preferred as it maintains prj info
newPlots_HARV <- readOGR("NEON-DS-Site-Layout-Files-HARV/HARV",
                         "newPlots_latLon")

#add these points to our existing plot  "Map of Study Area"
Harv_plotLocMap2
plot(newPlots_HARV, add=TRUE, col=115, pch=19)

#save new plot
Harv_plotLocMap3<- recordPlot()
```

We added the new plot locations to our existing plot and nothing happened.  Why?

What is the issue? Typically when data that we know should line up doesn't,
there is a projection issue. (Plus we should ALWAYS check projections/ CRS prior
to starting to work with any new spatial data.)

Often the coordinates can give us a clue as to whether the data are projected or
are in latitude and longitude (a geographic coordinate system).
We can use the `@coords` function to view the coordinates of the points in our
spatial object.

``` {r see-coords }
#view coordinates
newPlots_HARV@coords
```

It appears as if our coordinates for the two new plot locations are in latitude
and longitude. Let's check the CRS of our data to see if it is also in latitude
and longitude.
``` {r see-crs}
crs(newPlots_HARV)
```

Our `newPlots_HARV` shapefile is in a geographic coordinate system (latitude and 
longitude) instead of the UTM coordinate system of our other shapefiles. These
coordinates are not projected, and we need to reproject them in order to make
things line up in our map.

We can use the `spTransform` function to reproject a vector.

```{r project-data }
#double check the CRS of our plots layer
crs(plot.locationsSp_HARV)

#reproject our vector layer to the projection of our other plot data.
newPlots_HARV_UTM<- spTransform(newPlots_HARV,
                               crs(plot.locationsSp_HARV))

#check crs
crs(newPlots_HARV_UTM)
```

Now that the `CRSs` match we can add our new plot points to our existing map.  

```{r plot-reprojected-points}
#plot new plot location -- reprojected
#col & pch parameters to make it stand out!
Harv_plotLocMap3
plot(newPlots_HARV_UTM, add=TRUE, col=116, pch=19) 

```

Yes!  A nice blue point showed up for our new plot... but wait only one.  We 
have two new plots.  Why did only one appear?  

#Plotting - Order of Operations
We had 2 points in our new plots layer, however the only one new point
appeared on our map. This is due to the extent of the map, which is defined by 
the extent of the first layer plotted (all others are "added" to that layer). 

What happens if we create a new plot, but add the roads layer first?

```{r plot-data-order }
#add roads to our plot
plot(lines_HARV, main="Study Area")

#add the study plot locations 
plot(newPlots_HARV_UTM,add=T, col=116)
plot(plot.locationsSp_HARV, add=T)

#add the boundary layer 
plot(aoiBoundary_HARV, col="red", add=TRUE)

#add the tower 
plot(point_HARV, add =TRUE, pch=16)

```

We can see all the study plot locations now because we plotted the roads/trails 
layer (`lines_HARV`) first and it is the layer with the largest extent.  

#Plotting - Vector & Raster Layers Together
To create a visually pleasing map or to combine all the data we are interested
in we often need to combine raster and vector layers into one figure. We can
use the base `R` `plot()` command to create a vector-raster layered 
plot. 

We will use a Canopy Height Model (`chm`) from the Harvard forest as the base
layer for a map of our study locations.  

```{r Plot vector-raster overlay }

chm_HARV <- 
  raster("NEON-DS-Airborne-RemoteSensing-HARV-SJER/HARV/CHM/HARV_chmCrop.tif")

plot(chm_HARV,
     main="Map of Study Plots\n w/ Canopy Height Model\nNEON Harvard Forest")

plot(lines_HARV, add = TRUE)
plot(aoiBoundary_HARV, border="forestgreen", add = TRUE)
plot(plot.locationsSp_HARV, add = TRUE)
plot(newPlots_HARV_UTM, col="blue", add=TRUE)
plot(point_HARV, pch=17, add=TRUE)

```

<div id="challenge" markdown="1">
##Challenge: Useful Study Area Maps
Using a Digital Terrain Model
("NEON-DS-Airborne-RemoteSensing-HARV-SJER/HARV/DTM/HARV_dtmCrop.tif") 
create a usable map to the study area.  Include the following: 

1. Useful title, figure legends, and axes labels. 
2. Any or all vector layers that we have created. 
3. A customized color ramp. 
4. A color-coded system to identify the different types of roads or trails that
occur in the study site.  

For assistance consider using the 
[Shapefile Metadata & Attributes in R]({{site.baseurl}}/R/shapefile-attributes-in-R/),   
the [Plot Raster Data in R]({{site.baseurl}}/R/Plot-Rasters-In-R/ )   
or the
[Plot Raster Time Series Data in R Using RasterVis and Levelplot]({{site.baseurl}}/R/Plot-Raster-Times-Series-Data-In-R/) 
lessons. 
</div>

```{r challenge-code-plotting-pretty-map,  include=TRUE, results="hide", echo=FALSE}
#load DTM
DTM_HARV <- raster("NEON-DS-Airborne-RemoteSensing-HARV-SJER/HARV/DTM/HARV_dtmCrop.tif")

#create basic plot
plot(DTM_HARV,
     main="Map of Study Plots\n w/ Digital Terrain Model\nNEON Harvard Forest")

plot(aoiBoundary_HARV, border="forestgreen", add = TRUE)
plot(plot.locationsSp_HARV, pch=20, add = TRUE)
plot(newPlots_HARV_UTM, pch=20, col="blue", add=TRUE)
plot(point_HARV, pch=17, add=TRUE)

#legend
labels= c("footpath", "boardwalk", "tower")
labCols=c("red", "darkblue", "black")

#add lines w/ legend & different colors
#remind self what levels there are 
levels(lines_HARV@data$TYPE)

#create linetype 
lineType <- lines_HARV@data$TYPE

#set color for all lines not later specified
col <- rep(x= "black", length = length(lineType))

# color the boardwalks
col[lineType == "boardwalk"] <- "darkblue"
plot(lines_HARV, add=TRUE,
     legend("bottom", NULL, labels, fill=labCols, bty="n", cex=.8))
```
